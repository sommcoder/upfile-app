"use strict";
class FileUpload {
  constructor() {
    if (
      (console.log("6"),
      (this.productForm = document.querySelector(
        '[data-type="add-to-cart-form"]',
      )),
      (this.hiddenInput = null),
      (this.dropzoneForm = document.getElementById("upfile__dropzone-form")),
      (this.fileViewerWrapper = document.getElementById(
        "upfile__fileviewer--wrapper",
      )),
      this.dropzoneForm && this.fileViewerWrapper && this.productForm)
    )
      (this.dropzoneWrapper = this.dropzoneForm.querySelector(
        "#upfile__dropzone-wrapper",
      )),
        console.log("this.dropzoneWrapper:", this.dropzoneWrapper),
        (this.dropzoneFileInput = this.dropzoneWrapper.querySelector(
          "#upfile__manual-file-input",
        )),
        (this.dropzoneSelectBtn = this.dropzoneWrapper.querySelector(
          "#upfile__select-file-btn",
        )),
        (this.dropzoneText = this.dropzoneWrapper.querySelector(
          "#upfile__dropzone-text",
        )),
        (this.dropzoneFileSizeTally = this.dropzoneWrapper.querySelector(
          "#upfile__file-size-tally",
        )),
        (this.dropzoneFileSizeMax = this.dropzoneWrapper.querySelector(
          "#upfile__file-size-max",
        )),
        (this.fileViewerList = this.fileViewerWrapper.querySelector(
          "#upfile__fileviewer--item-list",
        )),
        (this.fileViewerOriginalRow = this.fileViewerList.querySelector(
          ".upfile__fileviewer--item-row",
        )),
        (this.fileViewerTrashIcon = this.fileViewerList.querySelector(
          ".upfile__fileviewer--trash-icon",
        )),
        (this.fileViewerStatus = this.fileViewerList.querySelector(
          ".upfile__fileviewer--item-status",
        )),
        (this.fileViewerLoadingSpinner =
          this.fileViewerList.querySelector(".upfile__spinner")),
        (this.fileViewerPlaceholder = this.fileViewerList.querySelector(
          "#upfile__fileviewer--placeholder",
        )),
        (this.fileViewerErrorList = this.fileViewerWrapper.querySelector(
          "#upfile__fileviewer--error-list",
        )),
        (this.fileViewerErrorItem = this.fileViewerWrapper.querySelector(
          ".upfile__fileviewer--error-item",
        )),
        (this.fileNameSet = new Set()),
        (this.fileViewerUIMap = new Map()),
        (this.fileStateObj = {}),
        (this.errorMessages = []),
        (this.totalStateFileSize = 0),
        (this.VALID_FILE_TYPES_OBJ = {}),
        (this.MAX_FILE_SIZE = null),
        (this.MAX_REQUEST_SIZE = null),
        (this.SHOPIFY_APP_PROXY_URL =
          this.dropzoneForm?.dataset.proxyUrl || ""),
        this.getMerchantSettings(),
        this.initEventListeners();
    else {
      const e = this.dropzoneForm?.querySelector(
        "#upfile__missing-block-notice",
      );
      e &&
        ((e.style.display = "flex"),
        (this.dropzoneForm.firstElementChild.style.display = "none"));
      const t = this.fileViewerWrapper?.querySelector(
        "#upfile__missing-block-notice",
      );
      t &&
        ((t.style.display = "flex"),
        (this.fileViewerWrapper.firstElementChild.style.display = "none"));
    }
  }
  addFileState(e, t) {
    (this.fileStateObj[e] = {
      id: e,
      name: t.name,
      size: t.size,
      type: t.type,
      status: null,
    }),
      this.fileNameSet.add(t.name),
      (this.totalStateFileSize += t.size);
  }
  updateFileStatus(e, t) {
    if (Object.hasOwn(this.fileStateObj, e)) {
      const i = t === "fulfilled" || t === "success" ? "success" : "failed";
      this.fileStateObj[e] = { ...this.fileStateObj[e], status: i };
      const r = this.fileViewerUIMap.get(e).querySelector("[data-status]");
      return (r.textContent = i), (r.dataset.status = i), !0;
    } else
      return console.error(`File with id: ${e} does not exist in state`), !1;
  }
  deleteFileState(e) {
    (this.totalStateFileSize -= this.fileStateObj[e].size),
      this.fileNameSet.delete(this.fileStateObj[e].name);
    const { [e]: t, ...i } = this.fileStateObj;
    (this.fileStateObj = i), this.fileViewerUIMap.delete(e);
  }
  validateSubmittedFile(e) {
    return (
      console.log("file:", e),
      Object.hasOwn(this.VALID_FILE_TYPES_OBJ, e.type) ||
        this.errorMessages.push(`'${e.name}' 
 is an invalid file type: (${e.type})`),
      e.size > this.MAX_FILE_SIZE &&
        (console.log("file.size:", e.size),
        this.errorMessages
          .push(`'${e.name}' exceeds the maximum size limit per file by: 
 ${this.formatToByteStr(e.size - this.MAX_FILE_SIZE)}`)),
      this.fileNameSet.has(e.name) &&
        this.errorMessages.push(`'${e.name}' 
 is a DUPLICATE file name`),
      this.totalStateFileSize + e.size > this.MAX_REQUEST_SIZE &&
        this.errorMessages.push(`'${e.name}' 
 exceeds the combined permitted submission size`),
      this.errorMessages.length > 0
        ? (console.log("this.errorMessages:", this.errorMessages), !1)
        : !0
    );
  }
  validateDraggedFile(e) {
    return !!Object.hasOwn(this.VALID_FILE_TYPES_OBJ, e.type);
  }
  formatToByteStr(e) {
    let t = e;
    const i = ["B", "KB", "MB", "GB"];
    let r = 0;
    for (; t >= 1024 && r < i.length - 1; ) (t /= 1024), r++;
    return `${t.toFixed(2)} ${i[r]}`;
  }
  prepareForFileUpload(e, t, i) {
    const r = crypto.randomUUID();
    this.addFileState(r, e),
      i.append("file_uuid", r),
      i.append("files", e),
      this.renderFileViewerSpinners(r, t);
  }
  togglePlaceholderUI() {
    this.fileViewerUIMap.size === 0 &&
      (this.fileViewerPlaceholder.style.display = "flex"),
      this.fileViewerUIMap.size === 1 &&
        (this.fileViewerPlaceholder.style.display = "none");
  }
  renderFileViewerItem(e) {
    let t = this.fileViewerOriginalRow.cloneNode(!0);
    (t.dataset.id = e.id),
      (t.querySelector("[data-type]").textContent =
        this.VALID_FILE_TYPES_OBJ[e.type]),
      (t.querySelector("[data-name]").textContent = e.name),
      (t.querySelector("[data-size]").textContent = this.formatToByteStr(
        e.size,
      ));
    const i = t.querySelector("[data-trash]");
    (i.dataset.id = e.id),
      i.addEventListener("click", (r) => {
        this.handleFileDelete(r.target.dataset.id);
      }),
      this.fileViewerList.appendChild(t),
      (t.style.display = "grid"),
      (t.style.opacity = 1),
      this.fileViewerUIMap.set(e.id, t),
      this.togglePlaceholderUI(),
      this.hideLoadingSpinner(e.id);
  }
  deleteFileViewerItem(e) {
    const t = this.fileViewerUIMap.get(e);
    this.fileViewerUIMap.delete(e), this.fileViewerList.removeChild(t);
  }
  addVariantProps(e) {
    console.log("id:", e),
      (this.hiddenInput = this.productForm?.querySelector(
        "input[name='properties[__upfile_id]']",
      )),
      this.hiddenInput
        ? (this.hiddenInput.value += `,${e}`)
        : ((this.hiddenInput = document.createElement("input")),
          (this.hiddenInput.type = "hidden"),
          (this.hiddenInput.name = "properties[__upfile_id]"),
          (this.hiddenInput.value = e),
          this.productForm.appendChild(this.hiddenInput)),
      console.log("this.hiddenInput:", this.hiddenInput);
  }
  deleteVariantProps(e) {
    if (this.hiddenInput) {
      console.log("this.hiddenInput.value:", this.hiddenInput.value);
      const t = this.hiddenInput.value
        .split(",")
        .filter((i) => i !== e)
        .join(",");
      (this.hiddenInput.value = t),
        console.log("this.hiddenInput.value:", this.hiddenInput.value);
    }
  }
  updateTallyElement() {
    this.dropzoneFileSizeTally.textContent = this.formatToByteStr(
      this.totalStateFileSize,
    );
  }
  resetDragUIState() {
    this.dropzoneWrapper.removeAttribute("data-status"),
      this.dropzoneWrapper.removeAttribute("data-drag"),
      this.dropzoneText.removeAttribute("data-status");
  }
  hideLoadingSpinner(e) {
    this.fileViewerList.querySelector(`[data-id="${e}"]`).style.display =
      "none";
  }
  renderFileViewerSpinners(e, t) {
    let i;
    t === 0
      ? (i = this.fileViewerLoadingSpinner)
      : (i = this.fileViewerLoadingSpinner.cloneNode(!0)),
      (i.dataset.id = e),
      (i.style.display = "block"),
      this.fileViewerList.appendChild(i);
  }
  renderErrorMessages() {
    (this.fileViewerErrorList.style.display = "flex"),
      this.errorMessages.forEach((e, t) => {
        let i = this.fileViewerErrorItem.cloneNode(!0);
        (i.style.display = "flex"),
          (i.textContent = e),
          this.fileViewerErrorList.appendChild(i),
          setTimeout(() => {
            i.parentNode === this.fileViewerErrorList &&
              (this.fileViewerErrorList.removeChild(i),
              (this.fileViewerErrorList.style.display = "none"));
          }, 8e3);
      });
  }
  resetErrorMessageList() {
    (this.errorMessages = []), (this.fileViewerErrorList.innerHTML = "");
  }
  async getMerchantSettings() {
    try {
      const e = await fetch(`${this.SHOPIFY_APP_PROXY_URL}/merchant`, {
        method: "GET",
      });
      if (!e.ok)
        throw (
          ((this.dropzoneForm.textContent = `Server Connection Issue:
 Please reload page`),
          (this.fileViewerWrapper.textContent = `Server Connection Issue:
 Please reload page`),
          new Error(`Failed to fetch settings: ${e.statusText}`))
        );
      if (e.ok) {
        const t = await e.json();
        console.log("data:", t),
          (this.VALID_FILE_TYPES_OBJ = t.fileTypeMap || []),
          (this.MAX_FILE_SIZE = t.maxFileSize),
          (this.MAX_REQUEST_SIZE = t.maxRequestSize),
          (this.dropzoneFileSizeTally.textContent = this.totalStateFileSize),
          (this.dropzoneFileSizeMax.textContent = this.formatToByteStr(
            this.MAX_REQUEST_SIZE,
          ));
      }
    } catch (e) {
      return console.error("getMerchantSettings()", e), null;
    }
  }
  async postFiles(e) {
    try {
      this.resetErrorMessageList();
      const t = e.filter((s) => this.validateSubmittedFile(s));
      if (this.errorMessages.length > 0 || t.length === 0) {
        this.renderErrorMessages();
        return;
      }
      const i = new FormData();
      t.forEach((s, a) => {
        this.prepareForFileUpload(s, a, i);
      });
      const r = await fetch(`${this.SHOPIFY_APP_PROXY_URL}/file`, {
        method: "POST",
        redirect: "manual",
        body: i,
        headers: { "Content-Length": this.totalStateFileSize.toString() },
      });
      if (!r.ok) throw new Error(`${r.status}: ${r.statusText}`);
      if (r.ok) {
        const s = await r.json();
        console.log("data:", s),
          s.forEach(({ value: a, status: l }) => {
            this.handleFileAdd(a, l);
          });
      }
    } catch (t) {
      console.error("postFiles():", t);
    }
  }
  async deleteFiles(e) {
    try {
      const t = await fetch(`${this.SHOPIFY_APP_PROXY_URL}/file`, {
        method: "DELETE",
        redirect: "manual",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(e),
      });
      if (!t.ok) throw new Error(`${t.status}: ${t.statusText}`);
      t.ok &&
        (await t.json()).forEach((r) => {
          r.status !== "fulfilled" &&
            console.error(`There was a server error in deleting file: ${r}`);
        });
    } catch (t) {
      console.error("postFiles():", t);
    }
  }
  initEventListeners() {
    this.dropzoneForm.addEventListener(
      "dragenter",
      this.handleDragEnter.bind(this),
    ),
      this.dropzoneForm.addEventListener("dragover", (e) => {
        e.preventDefault();
      }),
      this.dropzoneForm.addEventListener(
        "dragleave",
        this.handleDragLeave.bind(this),
      ),
      this.dropzoneForm.addEventListener("drop", this.handleDrop.bind(this)),
      this.dropzoneSelectBtn.addEventListener("click", (e) => {
        e.preventDefault(), this.dropzoneFileInput.click();
      }),
      this.dropzoneFileInput.addEventListener("change", (e) => {
        const t = Array.from(e.target.files);
        this.postFiles(t);
      });
  }
  handleFileAdd(e, t) {
    this.renderFileViewerItem(this.fileStateObj[e.id]),
      this.updateFileStatus(e.id, t) &&
        (this.addVariantProps(e.id), this.updateTallyElement());
  }
  handleFileDelete(e) {
    this.deleteVariantProps(e),
      this.deleteFileViewerItem(e),
      this.deleteFileState(e),
      this.updateTallyElement(),
      (this.errorMessages = []),
      this.togglePlaceholderUI(),
      this.deleteFiles([e]);
  }
  handleDragEnter(e) {
    e.preventDefault(),
      this.dropzoneWrapper.setAttribute("data-drag", "dragging");
    for (const t of e.dataTransfer.items)
      this.validateDraggedFile(t)
        ? (this.dropzoneWrapper.setAttribute("data-status", "valid"),
          this.dropzoneText.setAttribute("data-status", "valid"))
        : (this.dropzoneWrapper.setAttribute("data-status", "invalid"),
          this.dropzoneText.setAttribute("data-status", "invalid"));
  }
  handleDragLeave(e) {
    e.preventDefault(), this.resetDragUIState();
  }
  handleDrop(e) {
    e.preventDefault(),
      e.stopPropagation(),
      this.resetDragUIState(),
      this.postFiles(Array.from(e.dataTransfer.files));
  }
}
document.addEventListener("DOMContentLoaded", () => {
  new FileUpload();
});
